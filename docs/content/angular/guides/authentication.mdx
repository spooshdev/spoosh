---
title: Authentication
description: Managing tokens, headers, and auth flows
---

This guide covers common authentication patterns with Spoosh in Angular.

## Static Headers

Set a static token when creating the client:

```typescript
const spoosh = new Spoosh<ApiSchema, Error>("/api", {
  headers: {
    Authorization: "Bearer my-static-token",
  },
}).use([cachePlugin({ staleTime: 5000 }), invalidationPlugin()]);
```

## Dynamic Headers

The `headers` option accepts a function that runs before each request. Use this to read tokens from localStorage or state:

```typescript
const spoosh = new Spoosh<ApiSchema, Error>("/api", {
  headers: () => {
    const token = localStorage.getItem("accessToken");

    return token ? { Authorization: `Bearer ${token}` } : {};
  },
}).use([cachePlugin({ staleTime: 5000 }), invalidationPlugin()]);
```

### Async Headers

The function can also be async — useful when tokens need to be fetched or decrypted:

```typescript
const spoosh = new Spoosh<ApiSchema, Error>("/api", {
  headers: async () => {
    const token = await getTokenFromSecureStorage();

    return token ? { Authorization: `Bearer ${token}` } : {};
  },
}).use([cachePlugin({ staleTime: 5000 }), invalidationPlugin()]);
```

## Cookie Authentication

For cookie-based auth (session cookies, HttpOnly cookies), set `credentials: "include"`:

```typescript
const spoosh = new Spoosh<ApiSchema, Error>("/api", {
  credentials: "include",
}).use([cachePlugin({ staleTime: 5000 }), invalidationPlugin()]);
```

Cookies are automatically sent with every request. No manual header management needed.

## Token Refresh

Check if the access token is expired before each request. If expired, refresh it and update localStorage.

You can use any HTTP client for the refresh call. This example uses [`createClient`](/docs/angular/core/client#createclient) for type-safe API calls:

```typescript
import { SpooshPlugin, createClient } from "@spoosh/core";

// Define your API schema
type ApiSchema = {
  "auth/refresh": {
    POST: {
      data: { accessToken: string; refreshToken: string };
      body: { refreshToken: string };
    };
  };
  // ... other endpoints
};

function isTokenExpired(token: string): boolean {
  try {
    const payload = JSON.parse(atob(token.split(".")[1]));
    return payload.exp * 1000 < Date.now();
  } catch {
    return true;
  }
}

const api = createClient<ApiSchema>("/api");

async function refreshAccessToken(): Promise<string | null> {
  const refreshToken = localStorage.getItem("refreshToken");

  if (!refreshToken) return null;

  const { data } = await api("auth/refresh").POST({
    body: { refreshToken },
  });

  if (!data) return null;

  localStorage.setItem("accessToken", data.accessToken);
  localStorage.setItem("refreshToken", data.refreshToken);

  return data.accessToken;
}

function tokenRefreshPlugin(): SpooshPlugin {
  // Shared promise to prevent multiple concurrent refresh calls.
  // When several requests detect an expired token at the same time,
  // they all await the same promise instead of each triggering a refresh.
  let refreshPromise: Promise<string | null> | null = null;

  return {
    name: "token-refresh",
    operations: ["read", "write", "infiniteRead"],
    // Priority -20: Run before cache plugin (-10) to ensure tokens are refreshed
    // before checking cache, preventing stale token issues
    priority: -20,
    middleware: async (context, next) => {
      const t = context.tracer?.("token-refresh");
      let token = localStorage.getItem("accessToken");

      if (token && isTokenExpired(token)) {
        if (!refreshPromise) {
          t?.log("Token expired, refreshing", { color: "yellow" });
          refreshPromise = refreshAccessToken().finally(() => {
            refreshPromise = null;
          });
        }

        token = await refreshPromise;
      }

      if (token) {
        context.setHeaders({ Authorization: `Bearer ${token}` });
      }

      return next();
    },
  };
}
```

The `t` variable is a [tracer](/docs/angular/plugin-development/advanced/tracing) that emits events visible in [devtool](/docs/angular/devtool). It's optional — if devtool isn't installed, `context.tracer` is `undefined`.

Use it in your client:

```typescript
const spoosh = new Spoosh<ApiSchema, Error>("/api").use([
  tokenRefreshPlugin(), // priority: -20 (runs first)
  cachePlugin({ staleTime: 5000 }), // priority: -10 (runs second)
  invalidationPlugin(), // priority: 0 (default)
]);
```

> **Note:** Plugins are sorted by priority (lower runs first). For plugins with the same priority, registration order is preserved. Since these plugins have different priorities (-20, -10, 0), their execution order is guaranteed regardless of registration order.

## Handling Unauthorized Responses

Use `afterResponse` to globally handle 403 (forbidden) errors — for example, redirecting to login:

```typescript
function authErrorPlugin(): SpooshPlugin {
  return {
    name: "auth-error",
    operations: ["read", "write", "infiniteRead"],
    afterResponse: (context, response) => {
      if (response.status === 403) {
        localStorage.removeItem("accessToken");
        localStorage.removeItem("refreshToken");
        window.location.href = "/login";
      }
    },
  };
}
```

```typescript
const spoosh = new Spoosh<ApiSchema, Error>("/api").use([
  tokenRefreshPlugin(), // priority: -20 (runs first to refresh tokens)
  authErrorPlugin(), // priority: 0 (default, runs after cache)
  cachePlugin({ staleTime: 5000 }), // priority: -10 (runs second)
  invalidationPlugin(), // priority: 0 (default)
]);
```

Unlike `middleware`, `afterResponse` runs after every response — even when other plugins return early from cache. See [Middleware](/docs/angular//plugin-development/advanced/patterns) for more details.

## Clearing State on Logout

Combine `clearCache` and `invalidate("*")` to wipe all cached data:

```typescript
import { create } from "@spoosh/angular";

const { injectWrite, clearCache } = create(spoosh);

@Component({
  selector: "app-logout-button",
  template: `<button (click)="handleLogout()">Logout</button>`,
})
export class LogoutButtonComponent {
  private logoutWriter = injectWrite((api) => api("auth/logout").POST);

  async handleLogout() {
    await this.logoutWriter.trigger({ clearCache: true, invalidate: "*" });
    localStorage.removeItem("accessToken");
    localStorage.removeItem("refreshToken");
    window.location.href = "/login";
  }
}
```

For scenarios where you don't have a logout endpoint, use the instance `clearCache` directly:

```typescript
@Component({
  selector: "app-logout-button",
  template: `<button (click)="handleLogout()">Logout</button>`,
})
export class LogoutButtonComponent {
  handleLogout() {
    clearCache();
    localStorage.removeItem("accessToken");
    localStorage.removeItem("refreshToken");
    window.location.href = "/login";
  }
}
```

## Per-Request Headers

Override headers for a specific request:

```typescript
private adminAction = injectWrite((api) => api("admin/action").POST);

async performAction() {
  await this.adminAction.trigger({
    body: { action: "reset" },
    headers: { Authorization: "Bearer admin-token" },
  });
}
```
