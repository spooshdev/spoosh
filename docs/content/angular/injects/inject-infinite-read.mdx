---
title: injectInfiniteRead
description: Bidirectional paginated data fetching with infinite scroll support using Signals
---

> For usage patterns and examples, see the [Infinite Queries](/docs/angular/guides/infinite-queries) guide.

## Basic Usage

Given an API that returns:

```json
{
  "items": [
    { "id": 1, "title": "Post 1" },
    { "id": 2, "title": "Post 2" }
  ],
  "meta": { "page": 1, "hasMore": true }
}
```

```typescript
@Component({
  selector: "app-post-list",
  template: `
    @if (posts.loading()) {
      <div>Loading...</div>
    } @else {
      @for (post of posts.data(); track post.id) {
        <app-post-card [post]="post" />
      }

      @if (posts.canFetchNext()) {
        <button (click)="posts.fetchNext()" [disabled]="posts.fetchingNext()">
          {{ posts.fetchingNext() ? "Loading..." : "Load More" }}
        </button>
      }
    }
  `,
})
export class PostListComponent {
  posts = injectInfiniteRead(
    (api) => api("posts").GET({ query: { page: 1, limit: 20 } }),
    {
      canFetchNext: ({ response }) => response?.meta.hasMore ?? false,
      nextPageRequest: ({ response }) => ({
        query: { page: (response?.meta.page ?? 0) + 1 },
      }),
      merger: (allResponses) => allResponses.flatMap((r) => r.items),
    }
  );
}
```

## Options

| Option            | Type                         | Required | Description                                       |
| ----------------- | ---------------------------- | -------- | ------------------------------------------------- |
| `merger`          | `(allResponses) => TItem[]`  | Yes      | Merge all responses into items                    |
| `canFetchNext`    | `(ctx) => boolean`           | No       | Check if next page exists. Default: `() => false` |
| `nextPageRequest` | `(ctx) => Partial<TRequest>` | No       | Build request for next page                       |
| `canFetchPrev`    | `(ctx) => boolean`           | No       | Check if previous page exists                     |
| `prevPageRequest` | `(ctx) => Partial<TRequest>` | No       | Build request for previous page                   |
| `enabled`         | `boolean \| Signal<bool>`    | No       | Whether to fetch automatically                    |

## Context Object

```typescript
type Context<TData, TRequest> = {
  response: TData | undefined;
  allResponses: TData[];
  request: TRequest;
};
```

## Returns

| Property       | Type                           | Description                                     |
| -------------- | ------------------------------ | ----------------------------------------------- |
| `data`         | `Signal<TItem[] \| undefined>` | Merged items from all responses                 |
| `allResponses` | `Signal<TData[] \| undefined>` | Array of all raw responses                      |
| `loading`      | `Signal<boolean>`              | True during initial load                        |
| `fetching`     | `Signal<boolean>`              | True during any fetch                           |
| `fetchingNext` | `Signal<boolean>`              | True while fetching next page                   |
| `fetchingPrev` | `Signal<boolean>`              | True while fetching previous                    |
| `canFetchNext` | `Signal<boolean>`              | Whether next page exists                        |
| `canFetchPrev` | `Signal<boolean>`              | Whether previous page exists                    |
| `fetchNext`    | `() => Promise<void>`          | Fetch the next page                             |
| `fetchPrev`    | `() => Promise<void>`          | Fetch the previous page                         |
| `trigger`      | `(options?) => Promise<void>`  | Trigger fetch with optional new request options |
| `abort`        | `() => void`                   | Abort current request                           |
| `error`        | `Signal<TError \| undefined>`  | Error if request failed                         |
| `meta`         | `Signal<object>`               | Plugin-provided metadata                        |
