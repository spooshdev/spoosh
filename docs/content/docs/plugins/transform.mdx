---
title: Transform
description: Transform request and response data with full type inference
---

The Transform plugin enables per-request transformation of query, body, formData, urlEncoded, and response data. All transforms are defined at the hook level for full type inference.

## Installation

```package-install
@spoosh/plugin-transform
```

## Setup

```typescript
import { transformPlugin } from "@spoosh/plugin-transform";

const plugins = [transformPlugin()] as const;
```

## Usage

### Request Transforms (useRead)

Transform request data in hook options:

```typescript
const { data } = useRead((api) => api.posts.$get({ query: { page: 1 } }), {
  transform: {
    query: (q) => {
      // q is typed based on the endpoint schema
      if (q.category === "all") delete q.category;
      return { ...q, limit: 10 };
    },
  },
});
```

### Response Transforms (useRead)

Response transforms produce a separate `transformedData` field while preserving the original `data`:

```typescript
const { data, transformedData } = useRead((api) => api.posts.$get(), {
  transform: {
    response: (posts) => ({
      // posts is typed as the endpoint's response type
      count: posts.length,
      hasMore: posts.length >= 10,
      ids: posts.map((p) => p.id),
    }),
  },
});

// data = Post[] (original response, preserved)
// transformedData = { count: number, hasMore: boolean, ids: number[] } | undefined
```

The `transformedData` type is automatically inferred from your transformer's return type.

### Request Transforms (useWrite)

Transform request data in trigger options:

```typescript
const { trigger } = useWrite((api) => api.posts.$post);

trigger({
  body: { title: "New Post" },
  transform: {
    body: (b) => ({
      ...b,
      createdAt: Date.now(),
      version: "2.0",
    }),
  },
});
```

### Response Transforms (useWrite)

Just like `useRead`, response transforms for `useWrite` produce a separate `transformedData` field:

```typescript
const { trigger, data, transformedData } = useWrite((api) => api.posts.$post);

const response = await trigger({
  body: { title: "New Post" },
  transform: {
    response: (post) => ({
      // post is typed as the endpoint's response type
      success: true,
      postId: post.id,
      createdAt: new Date(post.timestamp),
    }),
  },
});

// After trigger completes:
// data = Post (original response, preserved)
// transformedData = { success: boolean, postId: number, createdAt: Date } | undefined
```

<Callout type="warning">
**TypeScript Limitation**: Due to TypeScript's limitations with dynamic trigger options, `transformedData` is typed as `never` in the hook result. You'll need to use type assertion to access it:

```typescript
const { transformedData } = useWrite((api) => api.posts.$post);

// Type assertion required
const typed = transformedData as
  | { success: boolean; postId: number }
  | undefined;
```

Alternatively, extract it from the trigger response:

```typescript
const { trigger } = useWrite((api) => api.posts.$post);

const response = await trigger({
  body: { title: "New Post" },
  transform: {
    response: (post) => ({ success: true, postId: post.id }),
  },
});

// Access from response
const result = response.data; // Post
// transformedData is available in the hook state after trigger completes
```

</Callout>

## Transform Types

### Query Transform

Transform query parameters before the request:

```typescript
const { data } = useRead(
  (api) => api.users.$get({ query: { status: "all", page: 1 } }),
  {
    transform: {
      query: (query) => {
        // Remove "all" status filter
        if (query.status === "all") {
          const { status, ...rest } = query;
          return rest;
        }
        return query;
      },
    },
  }
);
```

### Body Transform

Transform JSON body before the request:

```typescript
const { trigger } = useWrite((api) => api.posts.$post);

trigger({
  body: { title: "Hello" },
  transform: {
    body: (body) => ({
      ...body,
      timestamp: Date.now(),
      clientVersion: "1.0.0",
    }),
  },
});
```

### FormData Transform

Transform form data before the request:

```typescript
const { trigger } = useWrite((api) => api.files.$post);

trigger({
  formData: { file: selectedFile },
  transform: {
    formData: (fd) => ({
      ...fd,
      uploadedBy: currentUser.id,
      source: "web",
    }),
  },
});
```

### URL-Encoded Transform

Transform URL-encoded data before the request:

```typescript
const { trigger } = useWrite((api) => api.auth.token.$post);

trigger({
  urlEncoded: { client_id: "abc" },
  transform: {
    urlEncoded: (data) => ({
      ...data,
      grant_type: "client_credentials",
      scope: "read write",
    }),
  },
});
```

### Response Transform

Transform and analyze response data:

```typescript
const { data, transformedData } = useRead((api) => api.analytics.$get(), {
  transform: {
    response: (analytics) => ({
      totalViews: analytics.reduce((sum, a) => sum + a.views, 0),
      averageEngagement:
        analytics.reduce((sum, a) => sum + a.engagement, 0) / analytics.length,
      topPerformer: analytics.sort((a, b) => b.views - a.views)[0],
    }),
  },
});

// data = original analytics array
// transformedData = computed summary with totals and top performer
```

## Async Transforms

All transform functions support async operations:

```typescript
const { data } = useRead((api) => api.posts.$get(), {
  transform: {
    query: async (query) => {
      const token = await getAuthToken();
      return { ...query, token };
    },
  },
});
```

## Removing Data

Return `undefined` to remove the data entirely:

```typescript
const { data } = useRead(
  (api) => api.search.$get({ query: { q: "", filters: {} } }),
  {
    transform: {
      query: (query) => {
        // Remove query if search term is empty
        if (!query.q?.trim()) return undefined;
        return query;
      },
    },
  }
);
```

## Immutability

Data is deep-cloned before transformation, so you can safely mutate:

```typescript
transform: {
  query: (query) => {
    // Safe to mutate - original data is not affected
    delete query.internalField;
    query.normalized = true;
    return query;
  },
}
```

## Multiple Transforms

Apply multiple transforms in a single request:

```typescript
const { data, transformedData } = useRead(
  (api) => api.posts.$get({ query: { page: 1 } }),
  {
    transform: {
      query: (q) => ({ ...q, limit: 20 }),
      response: (posts) => ({
        count: posts.length,
        titles: posts.map((p) => p.title),
      }),
    },
  }
);
```

## Type Inference

The transform plugin provides full type inference:

```typescript
// Response type is inferred from endpoint (useRead)
const { data, transformedData } = useRead((api) => api.users.$get(), {
  transform: {
    response: (users) => {
      // 'users' is typed as User[]
      return {
        activeCount: users.filter((u) => u.active).length,
        admins: users.filter((u) => u.role === "admin"),
      };
    },
  },
});

// transformedData is typed as:
// { activeCount: number; admins: User[] } | undefined
```

### TypeScript Limitations with useWrite

For `useWrite`, there is a TypeScript limitation where `transformedData` is inferred as `never` in the hook result due to dynamic trigger options:

```typescript
const { trigger, transformedData } = useWrite((api) => api.posts.$post);

// transformedData is typed as 'never' here because TypeScript cannot infer
// the type from dynamic trigger options passed later

// ❌ Type error: transformedData is never
console.log(transformedData.success);

// ✅ Use type assertion
const typed = transformedData as
  | { success: boolean; postId: number }
  | undefined;
console.log(typed?.success);
```

This is a known TypeScript limitation with higher-order function type inference. For `useRead`, the options are passed at hook creation time, allowing full type inference. For `useWrite`, options are passed to `trigger` dynamically, which breaks TypeScript's ability to infer the result type.

**Workaround**: Define your transformed type separately:

```typescript
type TransformedPost = {
  success: boolean;
  postId: number;
  createdAt: Date;
};

const { trigger, transformedData } = useWrite((api) => api.posts.$post);

// Use type assertion
const transformed = transformedData as TransformedPost | undefined;
```

## Use Cases

### Compute Derived Data

```typescript
const { data, transformedData } = useRead((api) => api.orders.$get(), {
  transform: {
    response: (orders) => ({
      total: orders.reduce((sum, o) => sum + o.amount, 0),
      averageOrder:
        orders.reduce((sum, o) => sum + o.amount, 0) / orders.length,
      pendingCount: orders.filter((o) => o.status === "pending").length,
    }),
  },
});
```

### Filter Empty Query Params

```typescript
const { data } = useRead((api) => api.search.$get({ query: filters }), {
  transform: {
    query: (query) =>
      Object.fromEntries(
        Object.entries(query).filter(
          ([_, v]) => v !== undefined && v !== null && v !== ""
        )
      ),
  },
});
```

### Add Request Metadata

```typescript
const { trigger } = useWrite((api) => api.events.$post);

trigger({
  body: eventData,
  transform: {
    body: (body) => ({
      ...body,
      clientTimestamp: Date.now(),
      sessionId: getSessionId(),
      userAgent: navigator.userAgent,
    }),
  },
});
```
