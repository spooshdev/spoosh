---
title: Transform
description: Transform response data with full type inference
---

The Transform plugin enables per-request transformation of response data with full type inference.

## Installation

```package-install
@spoosh/plugin-transform
```

## Setup

```typescript
import { Spoosh } from "@spoosh/core";
import { transformPlugin } from "@spoosh/plugin-transform";

const client = new Spoosh<ApiSchema, Error>("/api").use([transformPlugin()]);
```

## Usage

### Response Transforms (useRead)

Response transforms produce a separate `transformedData` field in `meta` while preserving the original `data`:

```typescript
const { data, meta } = useRead((api) => api("posts").GET(), {
  transform: (posts) => ({
    count: posts.length,
    hasMore: posts.length >= 10,
    ids: posts.map((p) => p.id),
  }),
});

// data = Post[] (original response, preserved)
// meta.transformedData = { count: number, hasMore: boolean, ids: number[] } | undefined
```

The `meta.transformedData` type is automatically inferred from your transformer's return type.

### Response Transforms (useWrite)

Just like `useRead`, response transforms for `useWrite` produce a separate `transformedData` field in `meta`:

```typescript
const { trigger, data, meta } = useWrite((api) => api("posts").POST);

const response = await trigger({
  body: { title: "New Post" },
  transform: (post) => ({
    success: true,
    postId: post.id,
    createdAt: new Date(post.timestamp),
  }),
});

// After trigger completes:
// data = Post (original response, preserved)
// meta.transformedData = { success: boolean, postId: number, createdAt: Date } | undefined
```

<Callout type="warning">
**TypeScript Limitation**: Due to TypeScript's limitations with dynamic trigger options, `meta.transformedData` is typed as `never` in the hook result. You'll need to use type assertion to access it:

```typescript
const { meta } = useWrite((api) => api("posts").POST);

// Type assertion required
const typed = meta.transformedData as
  | { success: boolean; postId: number }
  | undefined;
```

Alternatively, extract it from the trigger response:

```typescript
const { trigger } = useWrite((api) => api("posts").POST);

const response = await trigger({
  body: { title: "New Post" },
  transform: (post) => ({ success: true, postId: post.id }),
});

// Access from response
const result = response.data; // Post
// meta.transformedData is available in the hook state after trigger completes
```

</Callout>

## Response Transform Examples

### Transform and Analyze Data

Transform and analyze response data:

```typescript
const { data, meta } = useRead((api) => api("analytics").GET(), {
  transform: (analytics) => ({
    totalViews: analytics.reduce((sum, a) => sum + a.views, 0),
    averageEngagement:
      analytics.reduce((sum, a) => sum + a.engagement, 0) / analytics.length,
    topPerformer: analytics.sort((a, b) => b.views - a.views)[0],
  }),
});

// data = original analytics array
// meta.transformedData = computed summary with totals and top performer
```

## Async Transforms

All transform functions support async operations:

```typescript
const { data, meta } = useRead((api) => api("posts").GET(), {
  transform: async (posts) => {
    const enriched = await enrichPostsWithMetadata(posts);
    return {
      count: enriched.length,
      titles: enriched.map((p) => p.title),
    };
  },
});
```

## Removing Data

Return `undefined` to remove the data entirely:

```typescript
const { data, meta } = useRead((api) => api("posts").GET(), {
  transform: (posts) => {
    if (posts.length === 0) return undefined;
    return {
      count: posts.length,
      titles: posts.map((p) => p.title),
    };
  },
});
```

## Type Inference

The transform plugin provides full type inference:

```typescript
// Response type is inferred from endpoint (useRead)
const { data, meta } = useRead((api) => api("users").GET(), {
  transform: (users) => {
    // 'users' is typed as User[]
    return {
      activeCount: users.filter((u) => u.active).length,
      admins: users.filter((u) => u.role === "admin"),
    };
  },
});

// meta.transformedData is typed as:
// { activeCount: number; admins: User[] } | undefined
```

### TypeScript Limitations with useWrite

For `useWrite`, there is a TypeScript limitation where `meta.transformedData` is inferred as `never` in the hook result due to dynamic trigger options:

```typescript
const { trigger, meta } = useWrite((api) => api("posts").POST);

// meta.transformedData is typed as 'never' here because TypeScript cannot infer
// the type from dynamic trigger options passed later

// ❌ Type error: transformedData is never
console.log(meta.transformedData.success);

// ✅ Use type assertion
const typed = meta.transformedData as
  | { success: boolean; postId: number }
  | undefined;
console.log(typed?.success);
```

This is a known TypeScript limitation with higher-order function type inference. For `useRead`, the options are passed at hook creation time, allowing full type inference. For `useWrite`, options are passed to `trigger` dynamically, which breaks TypeScript's ability to infer the result type.

**Workaround**: Define your transformed type separately:

```typescript
type TransformedPost = {
  success: boolean;
  postId: number;
  createdAt: Date;
};

const { trigger, meta } = useWrite((api) => api("posts").POST);

// Use type assertion
const transformed = meta.transformedData as TransformedPost | undefined;
```

## Use Cases

### Compute Derived Data

```typescript
const { data, meta } = useRead((api) => api("orders").GET(), {
  transform: (orders) => ({
    total: orders.reduce((sum, o) => sum + o.amount, 0),
    averageOrder: orders.reduce((sum, o) => sum + o.amount, 0) / orders.length,
    pendingCount: orders.filter((o) => o.status === "pending").length,
  }),
});
```

### Extract Specific Fields

```typescript
const { data, meta } = useRead((api) => api("posts").GET(), {
  transform: (posts) => ({
    ids: posts.map((p) => p.id),
    titles: posts.map((p) => p.title),
    publishedCount: posts.filter((p) => p.published).length,
  }),
});
```

### Enrich Response Data

```typescript
const { data, meta } = useRead((api) => api("users").GET(), {
  transform: (users) => ({
    totalUsers: users.length,
    activeUsers: users.filter((u) => u.active),
    usersByRole: users.reduce(
      (acc, u) => {
        acc[u.role] = (acc[u.role] || 0) + 1;
        return acc;
      },
      {} as Record<string, number>
    ),
  }),
});
```
