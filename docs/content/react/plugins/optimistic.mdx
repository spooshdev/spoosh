---
title: Optimistic Updates
description: Instant UI updates with automatic rollback on error
---

The optimistic plugin updates the UI immediately before the server responds. If the request fails, changes are automatically rolled back.

## Installation

```package-install
@spoosh/plugin-cache @spoosh/plugin-invalidation @spoosh/plugin-optimistic
```

> **Note:** This plugin requires `@spoosh/plugin-invalidation` as a peer dependency.

## Usage

```typescript
import { Spoosh } from "@spoosh/core";
import { cachePlugin } from "@spoosh/plugin-cache";
import { deduplicationPlugin } from "@spoosh/plugin-deduplication";
import { invalidationPlugin } from "@spoosh/plugin-invalidation";
import { optimisticPlugin } from "@spoosh/plugin-optimistic";

const client = new Spoosh<ApiSchema, Error>("/api").use([
  cachePlugin({ staleTime: 5000 }),
  deduplicationPlugin(),
  invalidationPlugin(),
  optimisticPlugin(),
]);
```

## Basic Optimistic Delete

Remove an item from a cached list immediately, before the server confirms:

```typescript
function PostList() {
  const { data, meta } = useRead((api) => api("posts").GET());
  const { trigger } = useWrite((api) => api("posts/:id").DELETE);

  const handleDelete = (id: number) => {
    trigger({
      params: { id },
      optimistic: (api) =>
        api("posts")
          .GET()
          .UPDATE_CACHE((posts) => posts.filter((p) => p.id !== id)),
    });
  };

  return (
    <div>
      {meta.isOptimistic && <span>Saving...</span>}
      <ul>
        {data?.map((post) => (
          <li key={post.id}>
            {post.title}
            <button onClick={() => handleDelete(post.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

The `UPDATE_CACHE` function receives the current cached data and returns the optimistically updated data.

## Optimistic Create

Prepend a new item to the list before the server responds:

```typescript
const { trigger } = useWrite((api) => api("posts").POST);

trigger({
  body: { title: "Draft Post", content: "..." },
  optimistic: (api) =>
    api("posts")
      .GET()
      .UPDATE_CACHE((posts) => [
        { id: Date.now(), title: "Draft Post", content: "..." },
        ...posts,
      ]),
});
```

## Using Response Data

Use `ON_SUCCESS` to update the cache with the actual server response instead of fabricated data:

```typescript
const { trigger } = useWrite((api) => api("posts").POST);

trigger({
  body: { title: "New Post", content: "..." },
  optimistic: (api) =>
    api("posts")
      .GET()
      .ON_SUCCESS()
      .UPDATE_CACHE((posts, newPost) => [newPost!, ...posts]),
});
```

The second argument to `UPDATE_CACHE` is the mutation response, available after the server responds successfully.

## Updating Multiple Caches

Return an array to update several cache entries at once:

```typescript
trigger({
  params: { id },
  optimistic: (api) => [
    api("posts")
      .GET()
      .UPDATE_CACHE((posts) => posts.filter((p) => p.id !== id)),
    api("stats")
      .GET()
      .UPDATE_CACHE((stats) => ({ ...stats, postCount: stats.postCount - 1 })),
  ],
});
```

## Filtering Cache Entries

When the same endpoint is called with different parameters, multiple cache entries exist. Use `WHERE` to target specific entries based on their request parameters:

```typescript
// If you have multiple cached queries:
// - useRead((api) => api("posts").GET({ query: { page: 1 } }))
// - useRead((api) => api("posts").GET({ query: { page: 2 } }))
// - useRead((api) => api("posts").GET({ query: { category: "tech" } }))

// Only prepend to page 1 results
trigger({
  body: newPost,
  optimistic: (api) =>
    api("posts")
      .GET()
      .WHERE((request) => request.query?.page === 1)
      .UPDATE_CACHE((posts) => [newPost, ...posts]),
});
```

Without `WHERE`, all cached entries for that endpoint would be updated. The `request` parameter in the callback contains the original request's `query`, `params`, and `body`:

```typescript
// Only update cache for a specific category
trigger({
  body: newPost,
  optimistic: (api) =>
    api("posts")
      .GET()
      .WHERE((request) => request.query?.category === newPost.category)
      .UPDATE_CACHE((posts) => [newPost, ...posts]),
});
```

## Detecting Optimistic State

The `meta.isOptimistic` flag indicates whether displayed data came from an optimistic update:

```typescript
function PostList() {
  const { data, meta } = useRead((api) => api("posts").GET());

  return (
    <div>
      {meta.isOptimistic && <div>Changes pending...</div>}
      {data?.map((post) => <PostCard key={post.id} post={post} />)}
    </div>
  );
}
```

## Controlling Rollback

By default, optimistic updates roll back on error. Use `NO_ROLLBACK` to keep the optimistic state:

```typescript
trigger({
  optimistic: (api) =>
    api("posts")
      .GET()
      .NO_ROLLBACK()
      .UPDATE_CACHE((posts) => [...posts, newPost]),
});
```

Handle errors manually with `ON_ERROR`:

```typescript
trigger({
  optimistic: (api) =>
    api("posts")
      .GET()
      .ON_ERROR((error) => {
        showToast(`Failed to save: ${error.message}`);
      })
      .UPDATE_CACHE((posts) => [...posts, newPost]),
});
```

## Combining with Invalidation

By default, optimistic updates set invalidation to `"none"` to prevent the server response from overwriting your optimistic data prematurely. To enable invalidation alongside optimistic updates:

```typescript
const { trigger } = useWrite((api) => api("posts/:id").DELETE);

trigger({
  params: { id },
  optimistic: (api) =>
    api("posts")
      .GET()
      .UPDATE_CACHE((posts) => posts.filter((p) => p.id !== id)),
  // "all" invalidates tags from the mutation path (posts/:id),
  // not the optimistic target path (posts)
  invalidate: "all",
});
```

## Options

### Per-Request Options

| Option       | Type                            | Description                           |
| ------------ | ------------------------------- | ------------------------------------- |
| `optimistic` | `(api) => builder \| builder[]` | Callback to define optimistic updates |

### Builder Methods (DSL)

Chain methods to configure optimistic updates:

| Method              | Description                               |
| ------------------- | ----------------------------------------- |
| `.GET()`            | Select the GET endpoint to update         |
| `.WHERE(fn)`        | Filter which cache entries to update      |
| `.UPDATE_CACHE(fn)` | Update cache immediately (default timing) |
| `.ON_SUCCESS()`     | Switch to onSuccess timing mode           |
| `.NO_ROLLBACK()`    | Disable automatic rollback on error       |
| `.ON_ERROR(fn)`     | Error callback                            |

### Timing Modes

| Usage                            | Description                                                                                          |
| -------------------------------- | ---------------------------------------------------------------------------------------------------- |
| `.UPDATE_CACHE(fn)`              | **Immediate** - Update cache instantly before request completes. Rollback on error.                  |
| `.ON_SUCCESS().UPDATE_CACHE(fn)` | **On Success** - Wait for successful response, then update cache. `fn` receives response as 2nd arg. |

### Result

The `useRead` hook returns plugin metadata via the `meta` property:

| Property            | Type      | Description                                         |
| ------------------- | --------- | --------------------------------------------------- |
| `meta.isOptimistic` | `boolean` | `true` if current data is from an optimistic update |
